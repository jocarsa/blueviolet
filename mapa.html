<!doctype html>
<html>
<head>
    <title>Mapa Viewer Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Get the image parameter from the URL
            const urlParams = new URLSearchParams(window.location.search);
            const imageName = urlParams.get('image');

            if (imageName) {
                const lowResMapUrl = `endpoint/mapas/${imageName}`;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                document.body.appendChild(canvas);

                // Set initial canvas size to window size
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // Load the low-resolution map
                const img = new Image();
                img.src = lowResMapUrl;
                img.onload = () => {
                    // Prepare the high-resolution map canvas
                    const scaleFactor = 64;
                    const highResCanvas = document.createElement('canvas');
                    highResCanvas.width = img.width * scaleFactor;
                    highResCanvas.height = img.height * scaleFactor;
                    const highResCtx = highResCanvas.getContext('2d');

                    // Draw and process the map to create the high-resolution version
                    drawHighResMap(ctx, img, scaleFactor, highResCanvas, highResCtx);

                    // Game logic variables
                    let playerX = highResCanvas.width / 2;
                    let playerY = highResCanvas.height / 2;
                    const playerSize = 10;
                    const speed = 2;

                    // Handle keyboard input
                    const keys = {};
                    window.addEventListener('keydown', (e) => {
                        keys[e.key] = true;
                    });
                    window.addEventListener('keyup', (e) => {
                        keys[e.key] = false;
                    });

                    // Game loop
                    function gameLoop() {
                        updatePlayerPosition();
                        drawGameView();
                        requestAnimationFrame(gameLoop);
                    }
                    requestAnimationFrame(gameLoop);

                    function updatePlayerPosition() {
                        let nextX = playerX;
                        let nextY = playerY;

                        if (keys['w'] || keys['ArrowUp']) nextY -= speed;
                        if (keys['s'] || keys['ArrowDown']) nextY += speed;
                        if (keys['a'] || keys['ArrowLeft']) nextX -= speed;
                        if (keys['d'] || keys['ArrowRight']) nextX += speed;

                        // Check collisions with walls
                        if (!isCollidingWithWall(nextX, playerY)) {
                            playerX = nextX;
                        }
                        if (!isCollidingWithWall(playerX, nextY)) {
                            playerY = nextY;
                        }
                    }

                    function drawGameView() {
                        // Clear the visible canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // Determine what part of the map to render based on player position
                        const viewWidth = canvas.width;
                        const viewHeight = canvas.height;
                        const offsetX = Math.max(0, Math.min(highResCanvas.width - viewWidth, playerX - viewWidth / 2));
                        const offsetY = Math.max(0, Math.min(highResCanvas.height - viewHeight, playerY - viewHeight / 2));
                        ctx.drawImage(highResCanvas, offsetX, offsetY, viewWidth, viewHeight, 0, 0, viewWidth, viewHeight);

                        // Draw the player at the center of the visible canvas
                        ctx.fillStyle = '#FF0000'; // Red player color
                        ctx.fillRect(canvas.width / 2 - playerSize / 2, canvas.height / 2 - playerSize / 2, playerSize, playerSize);
                    }

                    function drawHighResMap(ctx, img, scaleFactor, highResCanvas, highResCtx) {
                        // Draw low-resolution image onto a canvas
                        ctx.drawImage(img, 0, 0);
                        const lowResData = ctx.getImageData(0, 0, img.width, img.height);

                        // Create the high-resolution map on highResCanvas
                        for (let y = 0; y < img.height; y++) {
                            for (let x = 0; x < img.width; x++) {
                                const index = (y * img.width + x) * 4;
                                const r = lowResData.data[index];
                                const g = lowResData.data[index + 1];
                                const b = lowResData.data[index + 2];

                                if (r === 255 && g === 255 && b === 255) {
                                    drawTerrain(highResCtx, x * scaleFactor, y * scaleFactor, scaleFactor);
                                } else if (r === 0 && g === 0 && b === 0) {
                                    drawFloor(highResCtx, x * scaleFactor, y * scaleFactor, scaleFactor);
                                    // Check neighbors to draw walls
                                    if (isWhite(lowResData, x - 1, y, img.width)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'left', scaleFactor);
                                    if (isWhite(lowResData, x + 1, y, img.width)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'right', scaleFactor);
                                    if (isWhite(lowResData, x, y - 1, img.width)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'top', scaleFactor);
                                    if (isWhite(lowResData, x, y + 1, img.width)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'bottom', scaleFactor);
                                }
                            }
                        }
                    }

                    function isCollidingWithWall(x, y) {
                        const scaledX = Math.floor(x / scaleFactor);
                        const scaledY = Math.floor(y / scaleFactor);
                        if (scaledX < 0 || scaledY < 0 || scaledX >= highResCanvas.width / scaleFactor || scaledY >= highResCanvas.height / scaleFactor) {
                            return true;
                        }
                        const index = (scaledY * highResCanvas.width / scaleFactor + scaledX) * 4;
                        const r = highResCtx.getImageData(scaledX * scaleFactor, scaledY * scaleFactor, 1, 1).data[0];
                        const g = highResCtx.getImageData(scaledX * scaleFactor, scaledY * scaleFactor, 1, 1).data[1];
                        const b = highResCtx.getImageData(scaledX * scaleFactor, scaledY * scaleFactor, 1, 1).data[2];
                        return r === 44 && g === 62 && b === 80; // Wall color (dark blue/gray)
                    }
                };
            }
        });

        // Helper function to check if a pixel is white
        function isWhite(imageData, x, y, width) {
            if (x < 0 || y < 0 || x >= width || y >= imageData.height) return false;
            const index = (y * width + x) * 4;
            return imageData.data[index] === 255 && imageData.data[index + 1] === 255 && imageData.data[index + 2] === 255;
        }

        // Function to draw terrain
        function drawTerrain(ctx, x, y, size) {
            ctx.fillStyle = '#000000'; // Example terrain color (green)
            ctx.fillRect(x, y, size, size);
        }

        // Function to draw floor tiling
        function drawFloor(ctx, x, y, size) {
            ctx.fillStyle = '#BDC3C7'; // Example floor color (light gray)
            ctx.fillRect(x, y, size, size);
            ctx.strokeStyle = '#95A5A6'; // Tile border color (darker gray)
            ctx.strokeRect(x, y, size, size);
        }

        // Function to draw a wall
        function drawWall(ctx, x, y, direction, size) {
            ctx.fillStyle = '#2C3E50'; // Example wall color (dark blue/gray)
            switch (direction) {
                case 'left':
                    ctx.fillRect(x, y, size / 4, size);
                    break;
                case 'right':
                    ctx.fillRect(x + (3 * size) / 4, y, size / 4, size);
                    break;
                case 'top':
                    ctx.fillRect(x, y, size, size / 4);
                    break;
                case 'bottom':
                    ctx.fillRect(x, y + (3 * size) / 4, size, size / 4);
                    break;
            }
        }
    </script>
</body>
</html>

