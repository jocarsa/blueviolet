<!doctype html>
<html>
<head>
  <title>BlueViolet</title>
  <meta charset="utf-8">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #FFFFFF;
    }
    canvas {
      display: block;
    }
    .scoreboard {
      position: absolute;
      top: 50px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      font-size: 14px;
      color: #FFFFFF;
    }
    .winnerOverlay {
      position: absolute;
      top:0;
      left:0;
      width:100%;
      height:100%;
      background: rgba(0,255,0,0.2); /* green tint */
      pointer-events:none;
      display:none;
    }
    .winnerMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.7);
      padding: 20px;
      font-size: 24px;
      color: #00FF00;
      display:none;
    }
  </style>
</head>
<body>
  <div class="scoreboard" id="scoreboard"></div>
  <div class="winnerOverlay" id="winnerOverlay"></div>
  <div class="winnerMessage" id="winnerMessage">Ganador: </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const urlParams = new URLSearchParams(window.location.search);
      const imageName = urlParams.get('image');
      const playerColor = urlParams.get('color') || '#FF0000'; // Default color red
      const username = urlParams.get('username') || 'Player';
      const playerId = Math.floor(Math.random() * 10000); // Random player ID for demo

      if (!imageName) {
        console.error('No image name specified.');
        return;
      }

      const lowResMapUrl = `endpoint/mapas/${imageName}`;

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      document.body.appendChild(canvas);

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const img = new Image();
      img.src = lowResMapUrl;

      let totalGoals = 0;
      let collectedGoals = 0;
      let allGoalsCollected = false;

      let winnerId = null; // Will be set when we know there's a winner
      const scoreboardDiv = document.getElementById('scoreboard');
      const winnerOverlay = document.getElementById('winnerOverlay');
      const winnerMessage = document.getElementById('winnerMessage');

      img.onload = () => {
        const scaleFactor = 64;
        const highResCanvas = document.createElement('canvas');
        const highResCtx = highResCanvas.getContext('2d');

        ctx.drawImage(img, 0, 0);
        const lowResData = ctx.getImageData(0, 0, img.width, img.height);

        highResCanvas.width = img.width * scaleFactor;
        highResCanvas.height = img.height * scaleFactor;

        const collectibleColors = [
          {name: 'red',     r:255,g:0,  b:0},
          {name: 'green',   r:0,  g:255,b:0},
          {name: 'blue',    r:0,  g:0,  b:255},
          {name: 'yellow',  r:255,g:255,b:0},
          {name: 'magenta', r:255,g:0,  b:255},
          {name: 'cyan',    r:0,  g:255,b:255}
        ];

        let colorGoals = [];

        // Create a collision map
        const collisionMap = [];
        for (let y = 0; y < img.height; y++) {
          const row = [];
          for (let x = 0; x < img.width; x++) {
            const index = (y * img.width + x) * 4;
            const r = lowResData.data[index];
            const g = lowResData.data[index+1];
            const b = lowResData.data[index+2];
            const isOutside = (r === 255 && g === 255 && b === 255);
            row.push(isOutside ? 1 : 0);
          }
          collisionMap.push(row);
        }

        drawHighResMap(img, scaleFactor, highResCtx, lowResData, collectibleColors, colorGoals);
        totalGoals = colorGoals.length;

        let playerX = highResCanvas.width / 2;
        let playerY = highResCanvas.height / 2;
        let lastSentX = playerX;
        let lastSentY = playerY;
        const speed = 2;

        const keys = {};
        window.addEventListener('keydown', (e) => {
          keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => {
          keys[e.key] = false;
        });

        const playerSprite = new Image();
        playerSprite.src = 'personaje.png';

        const overlayCanvas = document.createElement('canvas');
        overlayCanvas.width = highResCanvas.width;
        overlayCanvas.height = highResCanvas.height;
        const overlayCtx = overlayCanvas.getContext('2d');
        overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        overlayCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        function paintVisitedArea(x, y) {
          const radius = 600;
          const grad = overlayCtx.createRadialGradient(x, y, 0, x, y, radius);
          grad.addColorStop(0, 'rgba(255,255,255,0.01)');
          grad.addColorStop(1, 'rgba(255,255,255,0)');

          overlayCtx.globalCompositeOperation = 'destination-out';
          overlayCtx.fillStyle = grad;
          overlayCtx.beginPath();
          overlayCtx.arc(x, y, radius, 0, 2 * Math.PI);
          overlayCtx.fill();
          overlayCtx.globalCompositeOperation = 'source-over';
        }

        let otherPlayersData = {};

        playerSprite.onload = () => {
          function gameLoop() {
            updatePlayerPosition();
            checkGoalCollection();
            paintVisitedArea(playerX, playerY);
            drawGameView();
            requestAnimationFrame(gameLoop);
          }
          requestAnimationFrame(gameLoop);
        };

        // Periodically fetch other players’ data (including their achievements)
        setInterval(async () => {
          const {players, winnerId: wId} = await getOtherPlayersPositions();
          winnerId = wId; // Store the winner ID
          players.forEach(player => {
            if (player.id !== playerId) {
              if (!otherPlayersData[player.id]) {
                otherPlayersData[player.id] = {
                  x: player.x,
                  y: player.y,
                  color: player.color,
                  prevX: player.x,
                  prevY: player.y,
                  lastUpdate: Date.now(),
                  username: player.username,
                  achievedGoals: player.achievedGoals,
                  totalGoals: player.totalGoals
                };
              } else {
                otherPlayersData[player.id].prevX = otherPlayersData[player.id].x;
                otherPlayersData[player.id].prevY = otherPlayersData[player.id].y;
                otherPlayersData[player.id].x = player.x;
                otherPlayersData[player.id].y = player.y;
                otherPlayersData[player.id].color = player.color;
                otherPlayersData[player.id].lastUpdate = Date.now();
                otherPlayersData[player.id].username = player.username;
                otherPlayersData[player.id].achievedGoals = player.achievedGoals;
                otherPlayersData[player.id].totalGoals = player.totalGoals;
              }
            }
          });

          // If there's a winner, show the winner overlay and highlight the winner
          if (winnerId) {
            winnerOverlay.style.display = 'block';
            winnerMessage.style.display = 'block';
            const winnerPlayer = (playerId === winnerId) ? {username: username} : 
              (otherPlayersData[winnerId] || {username: 'Unknown Winner'});
            winnerMessage.textContent = `Ganador: ${winnerPlayer.username}`;
          }

        }, 1000);

        // Send player data (including achievements) to server every second if moved or goals changed
        setInterval(() => {
          if (playerX !== lastSentX || playerY !== lastSentY || allGoalsCollected) {
            sendPlayerPosition(playerX, playerY, playerColor, collectedGoals, totalGoals);
            lastSentX = playerX;
            lastSentY = playerY;
          }
        }, 1000);

        function sendPlayerPosition(x, y, color, achievedGoals, totalGoals) {
          fetch('endpoint/multi.php', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
              id: playerId, 
              x: x, 
              y: y, 
              color: color, 
              username: username,
              achievedGoals: achievedGoals,
              totalGoals: totalGoals
            }),
          }).catch(error => console.error('Error sending player data:', error));
        }

        async function getOtherPlayersPositions() {
          try {
            const response = await fetch('endpoint/multi.php');
            if (!response.ok) {
              console.error('Failed to get other players positions:', response.status, response.statusText);
              return {players:[], winnerId:null};
            }
            const data = await response.json();
            return data;
          } catch (error) {
            console.error('Error getting other players positions:', error);
            return {players:[], winnerId:null};
          }
        }

        function canMoveTo(nx, ny) {
          const tileX = Math.floor(nx / scaleFactor);
          const tileY = Math.floor(ny / scaleFactor);
          if (tileX < 0 || tileY < 0 || tileX >= img.width || tileY >= img.height) {
            return false; // out of bounds
          }
          return collisionMap[tileY][tileX] === 0;
        }

        function updatePlayerPosition() {
          let nextX = playerX;
          let nextY = playerY;

          if (keys['w'] || keys['ArrowUp']) nextY -= speed;
          if (keys['s'] || keys['ArrowDown']) nextY += speed;
          if (keys['a'] || keys['ArrowLeft']) nextX -= speed;
          if (keys['d'] || keys['ArrowRight']) nextX += speed;

          if (canMoveTo(nextX, playerY)) {
            playerX = nextX;
          }
          if (canMoveTo(playerX, nextY)) {
            playerY = nextY;
          }
        }

        function checkGoalCollection() {
          for (let goal of colorGoals) {
            if (!goal.collected) {
              if (playerX >= goal.x && playerX < goal.x + goal.w &&
                  playerY >= goal.y && playerY < goal.y + goal.h) {
                goal.collected = true;
                collectedGoals++;
                if (collectedGoals === totalGoals) {
                  allGoalsCollected = true;
                }
              }
            }
          }
        }

        function drawGameView() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const viewWidth = canvas.width;
          const viewHeight = canvas.height;
          const offsetX = Math.max(0, Math.min(highResCanvas.width - viewWidth, playerX - viewWidth / 2));
          const offsetY = Math.max(0, Math.min(highResCanvas.height - viewHeight, playerY - viewHeight / 2));

          ctx.drawImage(highResCanvas, offsetX, offsetY, viewWidth, viewHeight, 0, 0, viewWidth, viewHeight);

          if (playerSprite.width > 0 && playerSprite.height > 0) {
            drawPlayerSprite(ctx, playerSprite, canvas.width / 2, canvas.height / 2, playerColor, username);
          }

          // Draw other players
          const currentTime = Date.now();
          Object.values(otherPlayersData).forEach(player => {
            const progress = Math.min(1, (currentTime - player.lastUpdate) / 1000);
            const interpolatedX = player.prevX + (player.x - player.prevX) * progress;
            const interpolatedY = player.prevY + (player.y - player.prevY) * progress;
            const otherPlayerX = interpolatedX - offsetX;
            const otherPlayerY = interpolatedY - offsetY;
            if (playerSprite.width > 0 && playerSprite.height > 0) {
              drawPlayerSprite(ctx, playerSprite, otherPlayerX, otherPlayerY, player.color || '#00FF00', player.username);
            }
          });

          // Draw fog of war
          ctx.drawImage(overlayCanvas, offsetX, offsetY, viewWidth, viewHeight, 0, 0, viewWidth, viewHeight);

          // Draw local player goals achievement
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(10,10,220,30);
          ctx.fillStyle = '#FFFFFF';
          ctx.font = "10px Sans-Serif";
          ctx.fillText(`Objetivos conseguidos: ${collectedGoals} of ${totalGoals}`, 20,30);

          // Update scoreboard with all players (local + others)
          drawScoreboard();

          // If there is a winner, the overlay and message are shown via CSS, already handled above
        }

        function drawScoreboard() {
          let scoreboardHTML = `<strong>Marcador</strong><br>`;
          // Local player
          scoreboardHTML += `${username} (Tú): ${collectedGoals}/${totalGoals}<br>`;
          // Other players
          for (const pId in otherPlayersData) {
            const p = otherPlayersData[pId];
            scoreboardHTML += `${p.username}: ${p.achievedGoals}/${p.totalGoals}<br>`;
          }
          scoreboardDiv.innerHTML = scoreboardHTML;
        }

        function drawPlayerSprite(ctx, sprite, x, y, color, username) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = sprite.width;
          tempCanvas.height = sprite.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(sprite, 0, 0);

          const imageData = tempCtx.getImageData(0, 0, sprite.width, sprite.height);
          const targetHue = getHueFromColor(color);
          for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] > 0) {
              const [h, s, l] = rgbToHsl(imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]);
              const [r, g, b] = hslToRgb(targetHue, s, l);
              imageData.data[i] = r;
              imageData.data[i + 1] = g;
              imageData.data[i + 2] = b;
            }
          }
          tempCtx.putImageData(imageData, 0, 0);

          ctx.drawImage(tempCanvas, x - sprite.width / 2, y - sprite.height / 2);
          ctx.fillStyle = '#FFFFFF';
          ctx.font = "40px Sans-serif";
          ctx.fillText(username, x - sprite.width / 2, y - sprite.height / 2 - 10);
        }

        function getHueFromColor(color) {
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          const [h] = rgbToHsl(r, g, b);
          return h;
        }

        function rgbToHsl(r, g, b) {
          r /= 255; g /= 255; b /= 255;
          const max = Math.max(r, g, b), min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          return [h * 360, s, l];
        }

        function hslToRgb(h, s, l) {
          h /= 360;
          let r, g, b;
          if (s === 0) {
            r = g = b = l;
          } else {
            const hue2rgb = (p, q, t) => {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
          }
          return [r * 255, g * 255, b * 255];
        }

        function drawHighResMap(img, scaleFactor, highResCtx, lowResData, collectibleColors, colorGoals) {
          for (let y = 0; y < img.height; y++) {
            for (let x = 0; x < img.width; x++) {
              const index = (y * img.width + x) * 4;
              const r = lowResData.data[index];
              const g = lowResData.data[index+1];
              const b = lowResData.data[index+2];

              const isWhite = (r===255 && g===255 && b===255);
              if (isWhite) {
                drawTerrain(highResCtx, x * scaleFactor, y * scaleFactor, scaleFactor);
              } else {
                drawFloor(highResCtx, x * scaleFactor, y * scaleFactor, scaleFactor);

                if (neighborIsOutside(x-1, y, lowResData, img.width, img.height)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'left', scaleFactor);
                if (neighborIsOutside(x+1, y, lowResData, img.width, img.height)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'right', scaleFactor);
                if (neighborIsOutside(x, y-1, lowResData, img.width, img.height)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'top', scaleFactor);
                if (neighborIsOutside(x, y+1, lowResData, img.width, img.height)) drawWall(highResCtx, x * scaleFactor, y * scaleFactor, 'bottom', scaleFactor);

                let matchedColor = collectibleColors.find(cc => cc.r === r && cc.g === g && cc.b === b);
                if (matchedColor) {
                  highResCtx.fillStyle = `rgb(${r},${g},${b})`;
                  highResCtx.fillRect(x * scaleFactor, y * scaleFactor, scaleFactor, scaleFactor);
                  colorGoals.push({
                    x: x * scaleFactor,
                    y: y * scaleFactor,
                    w: scaleFactor,
                    h: scaleFactor,
                    colorName: matchedColor.name,
                    collected: false
                  });
                }
              }
            }
          }
        }

        function neighborIsOutside(nx, ny, lowResData, width, height) {
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) return true;
          const idx = (ny * width + nx) * 4;
          const rr = lowResData.data[idx];
          const gg = lowResData.data[idx+1];
          const bb = lowResData.data[idx+2];
          return (rr===255 && gg===255 && bb===255);
        }

        function drawTerrain(ctx, x, y, size) {
          ctx.fillStyle = '#000000';
          ctx.fillRect(x, y, size, size);
        }

        function drawFloor(ctx, x, y, size) {
          ctx.fillStyle = '#BDC3C7';
          ctx.fillRect(x, y, size, size);
          ctx.strokeStyle = '#95A5A6';
          ctx.strokeRect(x, y, size, size);
        }

        function drawWall(ctx, x, y, direction, size) {
          ctx.fillStyle = '#2C3E50';
          switch (direction) {
            case 'left':
              ctx.fillRect(x, y, size / 4, size);
              break;
            case 'right':
              ctx.fillRect(x + (3 * size) / 4, y, size / 4, size);
              break;
            case 'top':
              ctx.fillRect(x, y, size, size / 4);
              break;
            case 'bottom':
              ctx.fillRect(x, y + (3 * size) / 4, size, size / 4);
              break;
          }
        }

      };
    });
  </script>
</body>
</html>

